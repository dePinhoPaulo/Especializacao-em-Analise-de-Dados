AULA_1: Orientações - Assista antes de começar

    Explicações;
    Biblioteca obrigatorio para area de dados


AULA_2: Arrays Numpy vs Listas

    É uma biblioteca fundamental para a computação científica em Python.
    E ele serve como uma boa base para o Pandas, que é uma das bibliotecas mais populares para análise de dados em Python.

    Tipo de dados: 
        As listas podem armazenar elementos de tipos diferentes ao mesmo tempo, enquanto os arrays armazenam elementos do mesmo tipo.
    Operações matemáticas: 
        Você pode realizar operações matemáticas em todos os elementos de um array de uma vez, o que não é possível com listas.
    Desempenho: 
        Arrays são mais eficientes em termos de memória e desempenho do que listas quando se trabalha com grandes quantidades de dados numéricos.
    Funcionalidades: 
        NumPy arrays vêm com várias funções integradas para operações matemáticas e científicas, como média, soma, multiplicação de matrizes, etc., que não estão disponíveis com listas.


AULA_3: Array Explicado

    Um array é uma estrutura de dados que armazena valores do mesmo tipo. 
    Em Python, isso é uma grande vantagem porque economiza espaço e permite operações mais eficientes.

    Indexaçãe e Slice:
        Muito parecido com a lista do python; 
        array[do elemento x : até o elemento y : pulando de z em z]


AULA_4: Funções Básicas de Array

    Aplicações do dia a dia
        precos = np.array([20, 25, 30, 35, 40])

        novos_precos = precos * 1.10
            "Alterar todos elementos da array"
        
        novos_precos = np.sum(vendas)
            "Somar todo array"
        
        media_vendas = np.mean(vendas)
            "Média do array"
        
        produto_mais_caro = np.max(precos)
        produto_mais_barato = np.min(precos)
            "Valor maximo e minimo do array"
        
        vendas_ordenadas = np.sort(vendas)
            "Ordenar valores do array"
        
        total_vendas = np.dot(quantidades, precos)
            "Recebe dois arrays e retorna a multiplicação item a item e soma tudo"


AULA_5: Exercícios Array

    Exercícios OK


AULA_6: Aleatórios e Estatística

    rng = np.random.default_rng()
        "Objeto gerador"
    numero_aleatorio = rng.random()
        "Numero Aleatorio (Sempre numeros entre 0 e 1)"
    print(numero_aleatorio)

    array_aleatorio = rng.random(3)
        "Array com 3 numeros aleatorios"
    
    rng = np.random.default_rng(seed=42)
        "gerador com seed (fixar a aleatoriedade)"
    dados_vendas = rng.integers(low=50, high=200, size=30)
        "Gera um array de numeros inteiros com minimo de 50 e maximo de 200 com 30 elementos"
    
    print(np.argmax(dados_vendas))
        "Posição do elemento maximo"
    print(np.argmin(dados_vendas))
        "Posição do elemento minimo"

    print(np.median(dados_vendas))          -> Mediana
    print(np.percentile(dados_vendas, 50))  -> Percentil
    print(np.std(dados_vendas))             -> Desvio padrão
    print(np.var(dados_vendas))             -> Variância


AULA_7: Where no Numpy

    funcionarios_acima_media = np.where(salarios > media_salarial)
        "Identificar funcionários com salários acima da média"
    
    "O Retorno será as posições dos elementos TRUE"

    print(np.where(salarios > media_salarial, 'acima da média', 'abaixo da média'))
        "Aqui retornara 'acima da média' para TRUE e 'abaixo da média' para elementos FALSE"
    
    salarios_bonus = np.where(salarios < media_salarial, salarios * 1.1, salarios)
        "Retornara salario com banus para acima da media, salario simple para abaixo"
        "Funciona muito parceido com o IF DAX"
    
    print(np.where((salarios >= 3000) & (salarios <= 4500)))
        "filtrar os salários entre 3000 e 4500 com where"
        "no Numpy Utilizamos & para E e | para OU, diferente do Python "Vanila" AND e OR"
    

AULA_8: Exercícios Numpy - Parte 1

    Exercícios OK


AULA_9: Exercícios Numpy - Parte 2

    Exercícios OK

